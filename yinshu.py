shu = (input('以[,]隔开每个数')).split(',')  # 输入数字
numbers = list(map(int, shu))  # 把元素整数化并映射map为数字列表化存入列表,这里不用去除,筛选
s = []  # 存贮遍历每个输入的数字可以除地板除得到的除数列表
ss = []  # 储存不能地板除的除数
sshu = min(numbers)  # 得到输入数字列表中的最小值
for y in numbers:  # 遍历输入的每个数字当做除数,用y代表当前所用的那个数字
    for i in range(2, sshu + 1):  # 遍历输入的每个数字,,当作被除数,从2开始除 因为1不算因数,i代表当前所用的那个数字 一直除到最小值本身,本身不用sshu加1表示
        if y % i == 0:  # 运行地板除 y是输入所有数字,i是从2到输入数值中最小的数字,地板除结果不能有余数所以==0
            s.append(i)  # 把可以整除的被除数统计append集合到s列表,后面要用它求差集,因为这些除数是每个输入的数字单个能整除的,不代表所有都可以整除
# print(sorted(set(s)))
# print('======================')
for y in numbers:  # 开始第二步筛选出来不能被所有整除的除数,先拿出来所有除数也就是输入的每一个数字并且列表化的列表numbers用y一个一个代替他们
    for ii in s:  # 这次用第一步获得的所有除数来循环调用,所有能被整除的除数列表是s,用ii代表每一个每一次开始遍历循环.
        if y % ii != 0:  # 找出能被某个数字不能被其他数字整除
            ss.append(ii)  # 找出来不能整除的除数后存进ss列表
sss = list(set(s) ^ set(ss))  # 求两个列表差集,获得能整除所有数字的被除数,所有能整除单个的都在s里,找出能整除单个却不能整除所有除数的在ss里,
# 用所有能的排除不能的.所有单个能的剔除全部整除测试不能用的的就是相差剩下都能的
ssss = sorted(set(sss))  # 把得到差集结果做个大小排序处理 ,并且去除相同字符.用到排序sorted和set清除相同两个函数
mss = max(ssss)  # 获得最大公约数,max 列表中最大的那个数字,min 迷你最小,max最大

print('{}中的共有因数有{}最大质因数是[{}]'.format(numbers, ssss, mss))  # 打印结果用format函数做占位符后面依次给出函数
